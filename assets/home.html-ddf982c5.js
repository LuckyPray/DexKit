import{_ as o,r as t,o as d,c,d as r,e,a as n,w as i,b as s}from"./app-402d39cd.js";const h={},l=s('<h1 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h1><blockquote><p><code>DexKit</code> 是一个使用 C++ 实现的 dex 高性能运行时解析库，用于查找被混淆的类、方法或者属性。</p></blockquote><h2 id="开发背景" tabindex="-1"><a class="header-anchor" href="#开发背景" aria-hidden="true">#</a> 开发背景</h2><p>在 Xposed 模块的开发中，我们通常需要对特定的方法进行 hook。然而，由于代码混淆，模块开发者往往不得不维护多个版本的 hook 点，以确保模块在不同版本下的兼容性。这种适配方式繁琐且容易出错。</p><p>有没有更好的解决方案呢？有些开发者可能会考虑遍历 ClassLoader 中的所有类，并通过反射遍历类的特征，如方法名、参数类型、 返回值类型和注解等，然后根据这些特征进行适配。然而，这种方式也有明显的缺点。首先，由于 Java 的反射机制本身耗时较长， 查找速度受设备性能影响。其次，在复杂条件下，查找可能需要较长时间，极端条件下甚至可能超过 30 秒。另外， 强行加载部分类可能会导致宿主 APP 出现不可预知的问题。</p><p>通常，开发者会对宿主 APP 进行反编译，获取 smali 或反编译后的 Java 代码，并通过已知的特征对代码进行搜索。 然后将结果写入适配文件。为了简化这个过程，我们需要一种自动化的方式。目前针对 Dex 文件的解析方案大多依赖于 <code>dexlib2</code>，但由于其是用 Java 开发，性能存在瓶颈。特别是当宿主应用存在大量 dex 文件时，解析时间会很长， 影响用户体验。为此，<code>DexKit</code> 应运而生。它采用 C++ 实现，性能优越的同时且内部使用多线程和多种算法进行优化， 能够在极短时间内完成复杂的搜索。</p><h2 id="语言要求" tabindex="-1"><a class="header-anchor" href="#语言要求" aria-hidden="true">#</a> 语言要求</h2><p>推荐使用 Kotlin 进行开发，因为其提供了 DSL 支持，可以让我们在使用 <code>DexKit</code> 时获得更好的体验。如果您不熟悉 Kotlin，也无需担心，API 也提供了相应的链式调用支持，同样能让 Java 开发者获得良好的体验。</p>',8);function p(_,x){const a=t("RouterLink");return d(),c("div",null,[l,r("p",null,[e("文档中的所有示例代码都将使用 Kotlin 编写。您可以通过 "),n(a,{to:"/zh-cn/"},{default:i(()=>[e("这里")]),_:1}),e(" 的示例，轻松了解相应的 Java 写法。")])])}const f=o(h,[["render",p],["__file","home.html.vue"]]);export{f as default};
