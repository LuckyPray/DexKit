import{_ as d,M as i,p as n,q as r,R as e,t,N as o,a1 as l}from"./framework-96b046e1.js";const c={},s=l('<h1 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识" aria-hidden="true">#</a> 基础知识</h1><p>您需要适当的了解一些基础知识，以便更好地使用 <code>DexKit</code>，包括但不限于：</p><ul><li>Dex反编译工具</li><li>JVM 签名 <ul><li>原始类型签名</li><li>引用类型签名</li><li>数组类型签名</li><li>方法签名</li><li>字段签名</li></ul></li></ul><h2 id="反编译工具" tabindex="-1"><a class="header-anchor" href="#反编译工具" aria-hidden="true">#</a> 反编译工具</h2>',4),g={href:"https://github.com/skylot/jadx",target:"_blank",rel:"noopener noreferrer"},h=l('<h2 id="jvm-签名" tabindex="-1"><a class="header-anchor" href="#jvm-签名" aria-hidden="true">#</a> JVM 签名</h2><h3 id="原始类型签名" tabindex="-1"><a class="header-anchor" href="#原始类型签名" aria-hidden="true">#</a> 原始类型签名</h3><table><thead><tr><th style="text-align:left;">类型签名</th><th style="text-align:left;">原始类型</th><th style="text-align:left;">大小（字节）</th></tr></thead><tbody><tr><td style="text-align:left;">V</td><td style="text-align:left;">void</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;">Z</td><td style="text-align:left;">boolean</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">B</td><td style="text-align:left;">byte</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">C</td><td style="text-align:left;">char</td><td style="text-align:left;">2</td></tr><tr><td style="text-align:left;">S</td><td style="text-align:left;">short</td><td style="text-align:left;">2</td></tr><tr><td style="text-align:left;">I</td><td style="text-align:left;">int</td><td style="text-align:left;">4</td></tr><tr><td style="text-align:left;">J</td><td style="text-align:left;">long</td><td style="text-align:left;">8</td></tr><tr><td style="text-align:left;">F</td><td style="text-align:left;">float</td><td style="text-align:left;">4</td></tr><tr><td style="text-align:left;">D</td><td style="text-align:left;">double</td><td style="text-align:left;">8</td></tr></tbody></table><h3 id="引用类型签名" tabindex="-1"><a class="header-anchor" href="#引用类型签名" aria-hidden="true">#</a> 引用类型签名</h3><p>引用数据类型包括类、接口、数组等，其中类和接口的类型签名都是以 <code>L</code> 开头，以 <code>;</code> 结尾，中间是类的全限定名，如 <code>Ljava/lang/String;</code>。</p><p>例如:</p><table><thead><tr><th style="text-align:left;">类型签名</th><th style="text-align:left;">java中类型</th></tr></thead><tbody><tr><td style="text-align:left;">Ljava/lang/String;</td><td style="text-align:left;">java.lang.String</td></tr><tr><td style="text-align:left;">Ljava/util/List;</td><td style="text-align:left;">java.util.List</td></tr></tbody></table><h3 id="数组类型签名" tabindex="-1"><a class="header-anchor" href="#数组类型签名" aria-hidden="true">#</a> 数组类型签名</h3><p>数组类型的类型签名以 <code>[</code> 开头，后面跟着数组元素的类型签名，如 <code>[[I</code> 表示一个二维数组，数组元素是 <code>int</code>。</p><p>例如:</p><table><thead><tr><th style="text-align:left;">类型签名</th><th style="text-align:left;">java中类型定义</th></tr></thead><tbody><tr><td style="text-align:left;">[I</td><td style="text-align:left;">int[]</td></tr><tr><td style="text-align:left;">[[C</td><td style="text-align:left;">char[][]</td></tr><tr><td style="text-align:left;">[Ljava/lang/String;</td><td style="text-align:left;">java.lang.String[]</td></tr></tbody></table><h3 id="方法签名" tabindex="-1"><a class="header-anchor" href="#方法签名" aria-hidden="true">#</a> 方法签名</h3><p>方法签名由方法的返回值类型签名和参数类型签名组成，如 <code>()V</code> 表示一个无参的 <code>void</code> 方法。</p><p>例如:</p><blockquote><p>为了方便表述，所有的方法名都是 <code>function</code></p></blockquote><table><thead><tr><th style="text-align:left;">方法签名</th><th style="text-align:left;">java中方法定义</th></tr></thead><tbody><tr><td style="text-align:left;">()V</td><td style="text-align:left;">void function()</td></tr><tr><td style="text-align:left;">(I)V</td><td style="text-align:left;">void function(int)</td></tr><tr><td style="text-align:left;">(II)V</td><td style="text-align:left;">void function(int, int)</td></tr><tr><td style="text-align:left;">(Ljava/lang/String;)V</td><td style="text-align:left;">void function(java.lang.String)</td></tr><tr><td style="text-align:left;">([I)V</td><td style="text-align:left;">void function(int[])</td></tr><tr><td style="text-align:left;">([[Ljava/lang/String;)V</td><td style="text-align:left;">void function(java.lang.String[][])</td></tr></tbody></table><h2 id="dalvik-描述" tabindex="-1"><a class="header-anchor" href="#dalvik-描述" aria-hidden="true">#</a> Dalvik 描述</h2><p>那么在dex中我们应该通过怎样的方式表达一个特定的方法/字段呢？没错，就是 <code>Dalvik 描述</code>。</p><h3 id="方法描述" tabindex="-1"><a class="header-anchor" href="#方法描述" aria-hidden="true">#</a> 方法描述</h3><p>方法描述的格式为 <code>[类签名]-&gt;[方法名][方法签名]</code>，如 <code>Ljava/lang/String;-&gt;length()I</code>。</p><blockquote><p><strong>注意</strong>： 在 <code>Dalvik 描述</code> 中，构造函数的方法名为 <code>&lt;init&gt;</code>，静态初始化函数的方法名为 <code>&lt;clinit&gt;</code>。</p></blockquote><h3 id="字段描述" tabindex="-1"><a class="header-anchor" href="#字段描述" aria-hidden="true">#</a> 字段描述</h3><p>字段描述的格式为 <code>[类签名]-&gt;[字段名]:[类型签名]</code>，如 <code>Ljava/lang/String;-&gt;count:I</code>。</p><blockquote><p><strong>注意</strong>: DexKit 查询参数支持填写 签名 或 java 原始写法，例如：</p><ul><li><p>对 className 相关查询参数，可以填写 <code>Ljava/lang/String;</code> 或 <code>java.lang.String</code>， 而 <code>java/lang/String</code> 是不受支持的。</p></li><li><p>对 <code>fieldType</code>/<code>returnType</code> 相关查询参数，可以填写 <code>I</code> 或 <code>int</code>。</p></li></ul></blockquote>',24);function f(x,y){const a=i("ExternalLinkIcon");return n(),r("div",null,[s,e("p",null,[t("正常情况下 "),e("a",g,[t("jadx"),o(a)]),t(" 足以应付大部分的需求，只需要一定程度上还原出Java的代码即可。")]),h])}const u=d(c,[["render",f],["__file","knowledge.html.vue"]]);export{u as default};
